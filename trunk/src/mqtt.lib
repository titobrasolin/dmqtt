/* START LIBRARY DESCRIPTION *********************************************
MQTT.LIB

The DMQTT Project
Copyright (C) 2013  Tito Brasolin tito.brasolin(at)gmail.com

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

DESCRIPTION: MQTT Client Library written in Dynamic C for Rabbit

The following libraries must be #use'd in this order:
#use ucos2.lib
#use dcrtcp.lib
#use modbus_slave.lib
#use modbus_slave_tcp.lib
#use mqtt.lib

END DESCRIPTION **********************************************************/

/*** BeginHeader */
#ifndef __MQTT_LIB
#define __MQTT_LIB

#ifdef MQTT_DEBUG
   #define _mqtt_debug __debug
#else
   #define _mqtt_debug __nodebug
#endif

#ifndef MQTT_VERBOSE
   #define MQTT_VERBOSE 0
#endif

// It is recommended that user names are kept to 12 characters or fewer,
// but it is not required.
#ifndef MQTT_MAXNAME
   #define MQTT_MAXNAME 13
#endif

// It is recommended that passwords are kept to 12 characters or fewer,
// but it is not required.
#ifndef MQTT_MAXPASS
   #define MQTT_MAXPASS 13
#endif

// MQTT_MAX_PACKET_SIZE : Maximum packet size
#define MQTT_MAX_PACKET_SIZE 128

// MQTT_KEEPALIVE : keepAlive interval in Seconds
#define MQTT_KEEPALIVE 15

#define MQTTPROTOCOLVERSION 3

#define MQTTCONNECT      1 << 4 // Client request to connect to Server
#define MQTTCONNACK      2 << 4 // Connect Acknowledgment
#define MQTTPUBLISH      3 << 4 // Publish message
#define MQTTPUBACK       4 << 4 // Publish Acknowledgment
#define MQTTPUBREC       5 << 4 // Publish Received (assured delivery part 1)
#define MQTTPUBREL       6 << 4 // Publish Release (assured delivery part 2)
#define MQTTPUBCOMP      7 << 4 // Publish Complete (assured delivery part 3)
#define MQTTSUBSCRIBE    8 << 4 // Client Subscribe request
#define MQTTSUBACK       9 << 4 // Subscribe Acknowledgment
#define MQTTUNSUBSCRIBE 10 << 4 // Client Unsubscribe request
#define MQTTUNSUBACK    11 << 4 // Unsubscribe Acknowledgment
#define MQTTPINGREQ     12 << 4 // PING Request
#define MQTTPINGRESP    13 << 4 // PING Response
#define MQTTDISCONNECT  14 << 4 // Client is Disconnecting
#define MQTTReserved    15 << 4 // Reserved

#define MQTTQOS0 (0 << 1)
#define MQTTQOS1 (1 << 1)
#define MQTTQOS2 (2 << 1)

typedef void (*mqttCallback)(far char*, uint8*, unsigned int);
typedef struct mqttConnection {
   char host[100];
   word port;
   char name[15];
   char pass[20];
   int state;
   void* socket;
   byte buffer[MQTT_MAX_PACKET_SIZE];
   word nextMsgId;
   longword lastOutActivity;
   longword lastInActivity;
   BOOLEAN pingOutstanding;
   mqttCallback callback;
   } mqttConnection;

#define _SOCK_OF_MQTT(state) _TCP_SOCK(state->sock)
typedef struct MqttState_t {
   void* sock;
   char state;
   char host[DNS_MAX_NAME]; // Null-terminated dotted ip address or host name.
   word port;
   char name[MQTT_MAXNAME]; // Null-terminated user name.
   char pass[MQTT_MAXPASS]; // Null-terminated password.
   void (*callback)();
   byte buffer[MQTT_MAX_PACKET_SIZE];
   word nextMsgId;
   longword epoch; // Session start time (MS_TIMER)
   long rx_ka; // RX keepalive timer. Use this to send KAs to server if no
               // messages sent in the interval.
   long tx_ka; // TX keepalive timer. If no KAs received from server in this
               // interval, can the connection.
   BOOLEAN pingOutstanding;
} MqttState;
/*** EndHeader */

/*** BeginHeader mqtt_Handler */
void mqtt_Handler(MqttState __far * s);
/*** EndHeader  */
void mqtt_Handler(MqttState __far * s) {
   // TODO: Handler, see modbus_slave.lib for inspiration.
}

/*** BeginHeader mqtt_init */
void mqtt_init(MqttState __far * s, tcp_Socket *t);
/*** EndHeader  */
_mqtt_debug
void mqtt_init(MqttState __far * s, tcp_Socket *t) {
   static int first_time = 1;
   _f_memset(s, 0, sizeof(*s));
   s->sock = t;
   // s->callback = ...
   if (first_time) {
      first_time = 0;
      // TODO: Something?
   }
}
/*** BeginHeader _mqtt_getElapsed */
char * _mqtt_getElapsed(MqttState __far * s);
/*** EndHeader  */
_mqtt_debug
char * _mqtt_getElapsed(MqttState __far * s) {
   static char stamp[20];
   longword ms = MS_TIMER - s->epoch;
   sprintf(stamp, "%06lu.%02u", ms / 1000, (word)(ms % 1000 / 10));
   return stamp;
}

/*** BeginHeader mqtt_send_msg */
int mqtt_send_msg(MqttState __far * s, byte header, void __far * msg, word len);
/*** EndHeader  */
_mqtt_debug
int mqtt_send_msg(MqttState __far * s, byte header, void __far * msg, word len)
{
   auto int wr;
   auto byte digit;
   auto byte lenBuf[4]; // Will represent the number of bytes remaining within
                        // the current message, including data in the variable
                        // header and the payload. The protocol limits the
                        // number of bytes in the representation to a maximum of
                        // four.
   auto word pos = 0;
   auto byte llen = 0;  // Actual number of bytes in the representation.

   // The table below shows the Remaining Length values represented by
   // increasing numbers of bytes.
   // +--------+------------------------------+--------------------------------+
   // | Digits |             From             |               To               |
   // +--------+------------------------------+--------------------------------+
   // |   1    | 0 (0x00)                     | 127 (0x7F)                     |
   // +--------+------------------------------+--------------------------------+
   // |   2    | 2,128 (0x80, 0x01)           | 16,383 (0xFF, 0x7F)            |
   // +--------+------------------------------+--------------------------------+
   // |   3    | 16,384 (0x80, 0x80, 0x01)    | 2,097,151 (0xFF, 0xFF, 0x7F)   |
   // +--------+------------------------------+--------------------------------+
   // |   4    | 2,097,152 (0x80, 0x80, 0x80, | 268,435,455 (0xFF, 0xFF, 0xFF, |
   // |        | 0x01)                        | 0x7F)                          |
   // +--------+------------------------------+--------------------------------+
   auto word X = len;
   // The algorithm for encoding a decimal number (X) into the variable length
   // encoding scheme is as follows.
   do {
      digit = X % 128;
      X = X / 128;
      if (X > 0) {
         digit |= 0x80;
      }
      lenBuf[pos++] = digit;
      llen++;
   } while(X>0);

   tcp_tick(NULL);
   wr = sock_writable(_SOCK_OF_MQTT(s));
   if (!wr) {
      // _mqtt_handle_error(_SOCK_OF_MQTT(s), 4); // TODO: Implement.
      return -EIO;
   }

   --wr;
   if ((word)wr < len+llen) {
      return -EAGAIN;
   }

#if MQTT_VERBOSE > 2
   #if MQTT_VERBOSE == 3
   if (TRUE) {
   #endif
   printf("\n%s --> MQTT: sending message\n", _mqtt_getElapsed(s));
   printf("  header=0x%02X\n", header);
   printf("  len=%u\n", len);
   mem_dump(msg, len);
   printf("\n");
   #if MQTT_VERBOSE == 3
   }
   #endif
#endif

   sock_noflush(_SOCK_OF_MQTT(s));
   sock_fastwrite(_SOCK_OF_MQTT(s), (char __far *)&header, 1);
   sock_fastwrite(_SOCK_OF_MQTT(s), (char __far *)lenBuf, llen);
   if (len) {
      sock_fastwrite(_SOCK_OF_MQTT(s), msg, len);
   }
   sock_flush(_SOCK_OF_MQTT(s));
   s->rx_ka = _SET_TIMEOUT(MQTT_KEEPALIVE*1000UL);
   return 0;
}

/*** BeginHeader mqttSetConnectInfo*/
void mqttSetConnectInfo(mqttConnection *conn, char *host,
      word port, char *name, char *pass, mqttCallback callback);
/*** EndHeader */
void mqttSetConnectInfo(mqttConnection *conn, char *host,
      word port, char *name, char *pass, mqttCallback callback) {
   conn->callback=callback;
   conn->port=port;
   strcpy(conn->host, host);
   strcpy(conn->name, name);
   strcpy(conn->pass, pass);
   }

/*** BeginHeader mqttConnect*/
void mqttConnect(mqttConnection *conn, void* socket);
/*** EndHeader */
void mqttConnect(mqttConnection *conn, void* socket) {
   int status;
   longword ip;
   conn->socket = socket;

   // Close an open socket. The socket cannot be reused until it is completely
   // closed. You can tell a tcp socket is closed e.g. by running
   // sock_wait_closed(s).
   sock_close(socket);

   // Reference to '_ip_delay2' has no corresponding prototype.
   #define _ip_delay2 ip_delay2
   sock_wait_closed(socket, 0, NULL, &status);

   // Wait for interface to come up, just in case.
   while (ifpending(IF_DEFAULT) == IF_COMING_UP) {
      tcp_tick(NULL);
   }

   ip = resolve(conn->host); // NOTE: this function blocks.
   tcp_open(conn->socket, 0, ip, conn->port, NULL);
   sock_mode(conn->socket, TCP_MODE_BINARY); // An arbitrary stream of bytes is allowed.

   sock_err:
      switch(status) {
         case 1: /* foreign host closed */
            printf("User closed session\n");
            break;
         case -1: /* time-out */
            printf("\nConnection timed out\n");
            break;
      }
}

/*** BeginHeader mqttHandleMessage*/
void mqttHandleMessage(mqttConnection *conn, char * msg);
/*** EndHeader */
void mqttHandleMessage(mqttConnection *conn, char * msg) {
   char *header;
   char *rest;
   char *body;
   char *dist;
   if (*msg=='\n')
      msg++;
   header=msg;
   rest=strchr(msg,'\n');
   if (rest!=NULL) {
      *rest='\0';
      rest++;
      body=strstr(rest,"\n\n");
      if (body!=NULL) {
         body+=2;
         if (strcmp(header,"MESSAGE")==0) {
            dist=strstr(rest,"destination:");
            if (dist!=NULL) {
               rest=strchr(dist,'\n');
               *rest='\0';
               (*(conn->onMessage))(dist+strlen("destination:"),body);
            }
         }
      }
   }
}

/*** BeginHeader mqttReadPacket*/
uint16 mqttReadPacket(MqttState __far * s, char * msg);
/*** EndHeader */
/*
The message header for each MQTT command message contains a fixed header.
The table below shows the fixed header format.
+--------+---+---+---+---+----------+-----+-----+--------+
|  bit   | 7 | 6 | 5 | 4 |    3     |  2  |  1  |    0   |
+--------+---+---+---+---+----------+-----+-----+--------+
| byte 1 |  Message Type | DUP flag | QoS level | RETAIN |
+--------+---------------+----------+-----------+--------+
| byte 2 |               Remaining Length                |
+--------+-----------------------------------------------+

Byte 1
   Contains the Message Type and Flags (DUP, QoS level, and RETAIN) fields.
Byte 2
   (At least one byte) contains the Remaining Length field.

*/
uint16 mqttReadPacket(MqttState __far * s, uint8* lengthLength) {
   uint16 len, length, i;
   uint8 digit, multiplier;

   // Byte 1 contains the Message Type and Flags (DUP, QoS level, and RETAIN)
   // fields.
   len = 0;
   s->buffer[len++] = sock_getc(_SOCK_OF_MQTT(s)); // NOTE: this function blocks.

   // Byte 2 (at least one byte) contains the Remaining Length field.
   // The variable length encoding scheme uses a single byte for messages up to
   // 127 bytes long. Longer messages are handled as follows. Seven bits of each
   // byte encode the Remaining Length data, and the eighth bit indicates any
   // following bytes in the representation. Each byte encodes 128 values and a
   // "continuation bit". For example, the number 64 decimal is encoded as a
   // single byte, decimal value 64, hex 0x40. The number 321 decimal
   // (= 65 + 2*128) is encoded as two bytes, least significant first. The first
   // byte 65+128 = 193. Note that the top bit is set to indicate at least one
   // following byte. The second byte is 2.
   digit = 0;
   length = 0;
   multiplier = 1;
   do {
      digit = sock_getc(_SOCK_OF_MQTT(s));
      s->buffer[len++] = digit;
      length += (digit & 127) * multiplier;
      multiplier *= 128;
   } while ((digit & 128) != 0);

   *lengthLength = len-1;

   for (i = 0;i<length;i++) {
      if (len < MQTT_MAX_PACKET_SIZE) {
         s->buffer[len++] = sock_getc(_SOCK_OF_MQTT(s));
      } else {
         sock_getc(_SOCK_OF_MQTT(s));
         len = 0; // This will cause the packet to be ignored.
      }
   }

   return len;
}

/*** BeginHeader mqttLoop*/
BOOLEAN mqttLoop(MqttState __far * s);
/*** EndHeader */
BOOLEAN mqttLoop(MqttState __far * s) {
   auto longword t;
   auto uint8 llen, type;
   auto uint16 len, tl, i;
   auto __far char *payload;
   auto __far char *topic;
   // TODO: Verify connection?
   // if (!connected) return FALSE; // Or something...
   tcp_tick(_SOCK_OF_MQTT(s));

   // The client sends a PINGREQ packet if it hasn't received anything from the
   // server within the KA interval.
   if (_CHK_TIMEOUT(s->rx_ka) || _CHK_TIMEOUT(s->tx_ka)) {
      if (s->pingOutstanding) {
         // _client->stop(); // <- ???
         return FALSE;
      } else {
         s->buffer[0] = MQTTPINGREQ;
         s->buffer[1] = '\0';
         sock_fastwrite(_SOCK_OF_MQTT(s),s->buffer,2); // TODO: check ret. value
         s->rx_ka = _SET_TIMEOUT(MQTT_KEEPALIVE*1000UL);
         s->tx_ka = _SET_TIMEOUT(MQTT_KEEPALIVE*1000UL);

         s->pingOutstanding = TRUE;
      }
   }

   if (sock_bytesready(_SOCK_OF_MQTT(s)) > 0) {
      len = mqttReadPacket(s, &llen);
      if (len > 0) {
         s->tx_ka = _SET_TIMEOUT(MQTT_KEEPALIVE*1000UL);
         type = s->buffer[0]&0xF0;
         if (type == MQTTPUBLISH) {
            if (s->callback) {
               tl = (s->buffer[llen+1]<<8)+s->buffer[llen+2];
               topic = malloc(tl+1);
               _f_memcpy(topic, &s->buffer[llen+3], tl);
               topic[tl] = '\0';
               // ignore msgID - only support QoS 0 subs
               payload = s->buffer+llen+3+tl;
               s->callback(topic,payload,len-llen-3-tl);
               free(topic);
            }
         } else if (type == MQTTPINGREQ) {
            s->buffer[0] = MQTTPINGRESP;
            s->buffer[1] = '\0';
            i = sock_fastwrite(_SOCK_OF_MQTT(s), s->buffer, 2);
            sock_flush(_SOCK_OF_MQTT(s));
         } else if (type == MQTTPINGRESP) {
            s->pingOutstanding = FALSE;
         }
      }
   }
   return TRUE;
   return FALSE; // <- If not connected?
}
/*** BeginHeader mqttTick*/
void mqttTick(mqttConnection *conn);
/*** EndHeader */
void mqttTick(mqttConnection *conn) {
   static char msg[800];
   static int p;
   int i;
   char buffer[200];
   int bytes_read;

   tcp_tick(conn->socket);
   if (p<0 || p>800) {
      p=0;
   }
   bytes_read=sock_fastread(conn->socket,buffer,sizeof(buffer)-1);

   if(bytes_read>0) {
      for (i=0;i<bytes_read;i++){
         if (buffer[i]!=0) {
            if (p>sizeof(msg)) {
               p=0;
            }
            msg[p]=buffer[i];
            p++;
         } else {
            msg[p]='\0';
            stompHandleMessage(conn, msg);
            p=0;
         }
      }
      buffer[bytes_read]=0;
   }
}

/*** BeginHeader mqttPublish*/
BOOLEAN mqttPublish(mqttConnection *conn, char* topic, uint8* payload,
      unsigned int plength, BOOLEAN retained);
/*** EndHeader */
BOOLEAN mqttConnected(mqttConnection *conn) { return TRUE; }
BOOLEAN mqttPublish(mqttConnection *conn, char* topic, uint8* payload,
      unsigned int plength, BOOLEAN retained) {
   auto uint16 length, i;
   auto uint8 header
   if (mqttConnected(conn)) {
      // Leave room in the buffer for header and variable length field.
      length = 5;
      length = _mqttWriteString(topic, conn->buffer, length);
      for (i=0; i<plength; i++) {
         conn->buffer[length++] = payload[i];
      }
      header = MQTTPUBLISH;
      if (retained) {
         header |= 1;
      }
      return write(header, conn->buffer, length-5);
   }
   return FALSE;
}

/*** BeginHeader */
#endif // __MQTT_LIB
/*** EndHeader */

