/* START LIBRARY DESCRIPTION *********************************************
MQTT.LIB

The DMQTT Project
Copyright (C) 2013  Tito Brasolin tito.brasolin(at)gmail.com

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

DESCRIPTION: MQTT Client Library written in Dynamic C for Rabbit

The following libraries must be #use'd in this order:
#use ucos2.lib
#use dcrtcp.lib
#use mqtt.lib

END DESCRIPTION **********************************************************/

/*** BeginHeader */
#ifndef __MQTT_LIB
#define __MQTT_LIB

// MQTT_MAX_PACKET_SIZE : Maximum packet size
#define MQTT_MAX_PACKET_SIZE 128

// MQTT_KEEPALIVE : keepAlive interval in Seconds
#define MQTT_KEEPALIVE 15

#define MQTTPROTOCOLVERSION 3

#define MQTTCONNECT      1 << 4 // Client request to connect to Server
#define MQTTCONNACK      2 << 4 // Connect Acknowledgment
#define MQTTPUBLISH      3 << 4 // Publish message
#define MQTTPUBACK       4 << 4 // Publish Acknowledgment
#define MQTTPUBREC       5 << 4 // Publish Received (assured delivery part 1)
#define MQTTPUBREL       6 << 4 // Publish Release (assured delivery part 2)
#define MQTTPUBCOMP      7 << 4 // Publish Complete (assured delivery part 3)
#define MQTTSUBSCRIBE    8 << 4 // Client Subscribe request
#define MQTTSUBACK       9 << 4 // Subscribe Acknowledgment
#define MQTTUNSUBSCRIBE 10 << 4 // Client Unsubscribe request
#define MQTTUNSUBACK    11 << 4 // Unsubscribe Acknowledgment
#define MQTTPINGREQ     12 << 4 // PING Request
#define MQTTPINGRESP    13 << 4 // PING Response
#define MQTTDISCONNECT  14 << 4 // Client is Disconnecting
#define MQTTReserved    15 << 4 // Reserved

#define MQTTQOS0 (0 << 1)
#define MQTTQOS1 (1 << 1)
#define MQTTQOS2 (2 << 1)

typedef void (*mqttCallback)(far char*, uint8*, unsigned int);
typedef struct mqttConnection {
   char host[100];
   word port;
   char name[15];
   char pass[20];
   int state;
   void* socket;
   byte buffer[MQTT_MAX_PACKET_SIZE];
   word nextMsgId;
   longword lastOutActivity;
   longword lastInActivity;
   BOOLEAN pingOutstanding;
   mqttCallback callback;
   } mqttConnection;

#define _SOCK_OF_MQTT(conn) ((conn)->socket)
/*** EndHeader */

BOOLEAN _mqttWrite(mqttConnection *conn, byte header, char __far * buf,
      word length) {
   auto int rc;
   auto byte digit
           , pos = 0;
   auto byte lenBuf[4]; // Will represent the number of bytes remaining within
                        // the current message, including data in the variable
                        // header and the payload. The protocol limits the
                        // number of bytes in the representation to a maximum of
                        // four.
   auto byte llen = 0;  // Actual number of bytes in the representation.
   // The table below shows the Remaining Length values represented by
   // increasing numbers of bytes.
   // +--------+------------------------------+--------------------------------+
   // | Digits |             From             |               To               |
   // +--------+------------------------------+--------------------------------+
   // |   1    | 0 (0x00)                     | 127 (0x7F)                     |
   // +--------+------------------------------+--------------------------------+
   // |   2    | 2,128 (0x80, 0x01)           | 16,383 (0xFF, 0x7F)            |
   // +--------+------------------------------+--------------------------------+
   // |   3    | 16,384 (0x80, 0x80, 0x01)    | 2,097,151 (0xFF, 0xFF, 0x7F)   |
   // +--------+------------------------------+--------------------------------+
   // |   4    | 2,097,152 (0x80, 0x80, 0x80, | 268,435,455 (0xFF, 0xFF, 0xFF, |
   // |        | 0x01)                        | 0x7F)                          |
   // +--------+------------------------------+--------------------------------+
   // The algorithm for encoding a decimal number (X) into the variable length
   // encoding scheme is as follows.
   uint16 X = length;
   do {
      digit = X % 128;
      X = X / 128;
      if (X > 0) {
         digit |= 0x80;
      }
      lenBuf[pos++] = digit;
      llen++;
   } while(X>0);

   buf[4-llen] = header;
   _f_memcpy(buf+(5-llen), lenBuf, llen);

   rc = sock_fastwrite(_SOCK_OF_MQTT(conn), buf+(4-llen), 1+llen+length);
   conn->lastOutActivity = MS_TIMER;

   return (rc == 1+llen+length);
}

uint16 _mqttWriteString(char* string, uint8* buf, uint16 pos) {
   auto char* idp = string;
   auto uint16 i = 0;

   pos += 2;
   while (*idp) {
      buf[pos++] = *idp++;
      i++;
   }
   buf[pos-i-2] = (i >> 8);
   buf[pos-i-1] = (i & 0xFF);
   return pos;
}

/*** BeginHeader mqttSetConnectInfo*/
void mqttSetConnectInfo(mqttConnection *conn, char *host,
      word port, char *name, char *pass, mqttCallback callback);
/*** EndHeader */
void mqttSetConnectInfo(mqttConnection *conn, char *host,
      word port, char *name, char *pass, mqttCallback callback) {
   conn->callback=callback;
   conn->port=port;
   strcpy(conn->host, host);
   strcpy(conn->name, name);
   strcpy(conn->pass, pass);
   }

/*** BeginHeader mqttConnect*/
void mqttConnect(mqttConnection *conn, void* socket);
/*** EndHeader */
void mqttConnect(mqttConnection *conn, void* socket) {
   int status;
   longword ip;
   conn->socket = socket;

   // Close an open socket. The socket cannot be reused until it is completely
   // closed. You can tell a tcp socket is closed e.g. by running
   // sock_wait_closed(s).
   sock_close(socket);

   // Reference to '_ip_delay2' has no corresponding prototype.
   #define _ip_delay2 ip_delay2
   sock_wait_closed(socket, 0, NULL, &status);

   // Wait for interface to come up, just in case.
   while (ifpending(IF_DEFAULT) == IF_COMING_UP) {
      tcp_tick(NULL);
   }

   if (isaddr(conn->host)) {
      ip = inet_addr(conn->host);
   } else {
      ip = resolve(conn->host); // NOTE: this function blocks.
   }
   tcp_open(conn->socket, 0, ip, conn->port, NULL);
   sock_mode(conn->socket, TCP_MODE_BINARY); // An arbitrary stream of bytes is allowed.

   sock_err:
      switch(status) {
         case 1: /* foreign host closed */
            printf("User closed session\n");
            break;
         case -1: /* time-out */
            printf("\nConnection timed out\n");
            break;
      }
}

/*** BeginHeader mqttHandleMessage*/
void mqttHandleMessage(mqttConnection *conn, char * msg);
/*** EndHeader */
void mqttHandleMessage(mqttConnection *conn, char * msg) {
   char *header;
   char *rest;
   char *body;
   char *dist;
   if (*msg=='\n')
      msg++;
   header=msg;
   rest=strchr(msg,'\n');
   if (rest!=NULL) {
      *rest='\0';
      rest++;
      body=strstr(rest,"\n\n");
      if (body!=NULL) {
         body+=2;
         if (strcmp(header,"MESSAGE")==0) {
            dist=strstr(rest,"destination:");
            if (dist!=NULL) {
               rest=strchr(dist,'\n');
               *rest='\0';
               (*(conn->onMessage))(dist+strlen("destination:"),body);
            }
         }
      }
   }
}

/*** BeginHeader mqttReadPacket*/
uint16 mqttReadPacket(mqttConnection *conn, char * msg);
/*** EndHeader */
/*
The message header for each MQTT command message contains a fixed header.
The table below shows the fixed header format.
+--------+---+---+---+---+----------+-----+-----+--------+
|  bit   | 7 | 6 | 5 | 4 |    3     |  2  |  1  |    0   |
+--------+---+---+---+---+----------+-----+-----+--------+
| byte 1 |  Message Type | DUP flag | QoS level | RETAIN |
+--------+---------------+----------+-----------+--------+
| byte 2 |               Remaining Length                |
+--------+-----------------------------------------------+

Byte 1
   Contains the Message Type and Flags (DUP, QoS level, and RETAIN) fields.
Byte 2
   (At least one byte) contains the Remaining Length field.

*/
uint16 mqttReadPacket(mqttConnection *conn, uint8* lengthLength) {
   uint16 len, length, i;
   uint8 digit, multiplier;

   // Byte 1 contains the Message Type and Flags (DUP, QoS level, and RETAIN)
   // fields.
   len = 0;
   conn->buffer[len++] = sock_getc(conn->socket); // NOTE: this function blocks.

   // Byte 2 (at least one byte) contains the Remaining Length field.
   // The variable length encoding scheme uses a single byte for messages up to
   // 127 bytes long. Longer messages are handled as follows. Seven bits of each
   // byte encode the Remaining Length data, and the eighth bit indicates any
   // following bytes in the representation. Each byte encodes 128 values and a
   // "continuation bit". For example, the number 64 decimal is encoded as a
   // single byte, decimal value 64, hex 0x40. The number 321 decimal
   // (= 65 + 2*128) is encoded as two bytes, least significant first. The first
   // byte 65+128 = 193. Note that the top bit is set to indicate at least one
   // following byte. The second byte is 2.
   digit = 0;
   length = 0;
   multiplier = 1;
   do {
      digit = sock_getc(conn->socket);
      conn->buffer[len++] = digit;
      length += (digit & 127) * multiplier;
      multiplier *= 128;
   } while ((digit & 128) != 0);

   *lengthLength = len-1;

   for (i = 0;i<length;i++) {
      if (len < MQTT_MAX_PACKET_SIZE) {
         conn->buffer[len++] = sock_getc(conn->socket);
      } else {
         sock_getc(conn->socket);
         len = 0; // This will cause the packet to be ignored.
      }
   }

   return len;
}

/*** BeginHeader mqttLoop*/
BOOLEAN mqttLoop(mqttConnection *conn);
/*** EndHeader */
BOOLEAN mqttLoop(mqttConnection *conn) {
   auto longword t;
   auto uint8 llen, type;
   auto uint16 len, tl, i;
   auto uint8 *payload;
   auto char far *topic;
   // TODO: Verify connection?
   // if (!connected) return FALSE; // Or something...
   tcp_tick(conn->socket);
   t = MS_TIMER;

   // The client sends a PINGREQ packet if it hasn't received anything from the
   // server within the KA interval.
   if ((t - conn->lastInActivity > MQTT_KEEPALIVE*1000UL)
         || (t - conn->lastOutActivity > MQTT_KEEPALIVE*1000UL)) {
      if (conn->pingOutstanding) {
         // _client->stop(); // <- ???
         return FALSE;
      } else {
         conn->buffer[0] = MQTTPINGREQ;
         conn->buffer[1] = '\0';
         sock_fastwrite(conn->socket,conn->buffer,2); // TODO: check ret. value
         conn->lastOutActivity = t;
         conn->lastInActivity = t;
         conn->pingOutstanding = TRUE;
      }
   }

   if (sock_bytesready(conn->socket) > 0) {
      len = mqttReadPacket(conn, &llen);
      if (len > 0) {
         conn->lastInActivity = t;
         type = conn->buffer[0]&0xF0;
         if (type == MQTTPUBLISH) {
            if (conn->callback) {
               tl = (conn->buffer[llen+1]<<8)+conn->buffer[llen+2];
               topic = malloc(tl+1);
               _f_memcpy(topic, &conn->buffer[llen+3], tl);
               topic[tl] = '\0';
               // ignore msgID - only support QoS 0 subs
               payload = conn->buffer+llen+3+tl;
               conn->callback(topic,payload,len-llen-3-tl);
               free(topic);
            }
         } else if (type == MQTTPINGREQ) {
            conn->buffer[0] = MQTTPINGRESP;
            conn->buffer[1] = '\0';
            i = sock_fastwrite(conn->socket, conn->buffer, 2);
            sock_flush(conn->socket);
         } else if (type == MQTTPINGRESP) {
            conn->pingOutstanding = FALSE;
         }
      }
   }
   return TRUE;
   return FALSE; // <- If not connected?
}
/*** BeginHeader mqttTick*/
void mqttTick(mqttConnection *conn);
/*** EndHeader */
void mqttTick(mqttConnection *conn) {
   static char msg[800];
   static int p;
   int i;
   char buffer[200];
   int bytes_read;

   tcp_tick(conn->socket);
   if (p<0 || p>800) {
      p=0;
   }
   bytes_read=sock_fastread(conn->socket,buffer,sizeof(buffer)-1);

   if(bytes_read>0) {
      for (i=0;i<bytes_read;i++){
         if (buffer[i]!=0) {
            if (p>sizeof(msg)) {
               p=0;
            }
            msg[p]=buffer[i];
            p++;
         } else {
            msg[p]='\0';
            stompHandleMessage(conn, msg);
            p=0;
         }
      }
      buffer[bytes_read]=0;
   }
}

/*** BeginHeader mqttPublish*/
BOOLEAN mqttPublish(mqttConnection *conn, char* topic, uint8* payload,
      unsigned int plength, BOOLEAN retained);
/*** EndHeader */
BOOLEAN mqttConnected(mqttConnection *conn) { return TRUE; }
BOOLEAN mqttPublish(mqttConnection *conn, char* topic, uint8* payload,
      unsigned int plength, BOOLEAN retained) {
   auto uint16 length, i;
   auto uint8 header
   if (mqttConnected(conn)) {
      // Leave room in the buffer for header and variable length field.
      length = 5;
      length = _mqttWriteString(topic, conn->buffer, length);
      for (i=0; i<plength; i++) {
         conn->buffer[length++] = payload[i];
      }
      header = MQTTPUBLISH;
      if (retained) {
         header |= 1;
      }
      return write(header, conn->buffer, length-5);
   }
   return FALSE;
}

/*** BeginHeader */
#endif // __MQTT_LIB
/*** EndHeader */

